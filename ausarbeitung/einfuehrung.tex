\chapter{Einführung}
\section{Aufgabenstellung}
Ziel dieses Praktikums war es eine Software zu konstruieren um \QRCodes in Bildern zu lokalisieren und danach zu extrahieren.
Dabei sollten sich die Teams auf \QRCodes, die dem ISO/IEC Standard 18004 entsprechen, beschränken.
Unter der Annahme, dass sämtliche \QRCodes auf den Eingabebildern planar waren, sollten perspektivische Transformationen oder ähnliche Verzerrungen entfernt werden.
Zusätzlich sollte sich jedes Team darum kümmern ein \emph{Dataset} zur Analyse und späteren Evaluation zu erschaffen.
 
\section{Aufbau des \QRCodes}
Um das spätere Vorgehen der Lokalisierung des \QRCodes nachvollziehen zu können, wollen wir kurz auf den Aufbau des \QRCodes eingehen.
Wie in der Abbildung \ref{fig:struktur-qrcode} zu sehen ist, sind im Code die Informationen zur Version, Format und der Fehlerkorrektur enthalten. 

\begin{figure}[h]
\centering
\includegraphics[scale=0.3]{images/QR_Code_Struktur_Beispiel.png}
\label{fig:struktur-qrcode}\caption{\QRCode Strukturbeispiel}
\end{figure}
\todo{Quellen angeben!}

Des weiteren ist klar zu erkennen, dass der Code in drei von vier Ecken das Muster 4.1 vorweist. Diese dienen zur Bestimmung der Orientierung. Zusätzlich wird das Muster 4.2 (\emph{Finder Pattern}) verwendet um die Ausrichtung noch prezieser zu bestimmen. Bei größeren \QRCodes werden weitere Ausrichtungsmuster (Muster 4.2) eingefügt. Zwischen den \emph{Finder Patterns} befindet sich ein Streifen mit abwechselnd \glqq schwarz - weißen\grqq\  Punkten (\emph{Modulen}). Das sind die so genannten Synchronisations Muster oder auch \emph{Timming Patterns}.

Die Größe der \QRCodes ist beschränkt durch die Anzahl der \emph{Module}. Die Anzahl der \emph{Module} liegt zwischen $21 \times 21$ und $177 \times 177$. Beispielsweise sei der Code in Abbildung \ref{fig:struktur-qrcode} einer der Größe $21 \times 21$. Dann hätte ein \emph{Finder Pattern} die länge von $7$ \emph{Modules}. Die Anzahl ergibt sich aus der einzigartigen $1:1:3:1:1$ Struktur eines \emph{Finder Patterns}. Diese Fakten werden später ausschlagegebend sein bei der Rasterisierung des \QRCodes.

\section{Die verwendette Bibliothek OpenCV}
\OpenCV\footnote{WWW-Seite von dem Projekt \OpenCV: \url{http://opencv.org/}} ist eine Bibliothek mit Algorithmen spezialisiert auf \glqq Computer Vision\grqq . Sie wurde für die Programmiersprachen C/C++ geschrieben und steht unter BSD Lizenz. Es gibt mehrere Versionen der Bibliothek, die aktuellste ist die 3.2. Unser Programm setzt  die mindestanforderung auf Version 2.4. Außer \OpenCV wurde keine weitere Bibliothek verwendet. 



\chapter{Bildvorverarbeitung}
Die Bildvorverarbeitung ist ein essenzieller Schritt um die \QRCodes richtig lokalisieren zu können. Das Eingabebild soll in dieser Phase erstmal in ein Graustufenbild umgewandelt werden und danach binarisiert werden. \OpenCV bietet die Möglichkeit bilder direkt als Graustufenbild einzulesen oder sie in eins umzuwandeln. Das in Graustufen vorhandene Bild kann weiter verarbeitet werden.
Die Klasse \texttt{ImageBinarization} ist für die binarisierung zuständig. 
\inputCPP[label={lst:binarize}][][Der Gesamtablauf der Binarisierung.]{code/binarize-run.cpp}

Listing \ref{lst:binarize} zeigt den Ablauf der Binarisierung. In Zeile 4 wird die Methode \texttt{computeSmoothing} aufgerufen, die eine Gaußglättung auf dem Bild durchführt, um eventuelles Rauschen zu mindern. Im nächsten Schritt wird ein Farbstufen-Histogramm mithilfe der \texttt{computeHistogram} Methode berechnet. Um die best Mögliche Binarisierung zu erreichen, wurden drei Methoden zur Schwellwert Berechnung implementiert:
\begin{itemize}
	\item globales Schwellwertverfahren,
	\item Mittelwert basiertes Schwellwertverfahren,
	\item Gauß'sches Schwellwertverfahren.
\end{itemize} 
Im ersten durchlauf wird das globale Schwellwertverfahren angewandt. Sollte dies keine gültige Ergebnisse liefern (keine drei \emph{Finder Pattern} enthalten), so wird das nächste Verfahren gewählt.
Abhängig von der Wahl werden zwei verschiedene \OpenCV Methoden verwendett. Bei der globalen Schwellwert Berechnung wird auf die \texttt{threshold} Methode wie sie im Listing \ref{lst:globalthreshold} steht zurückgegriffen. Der Methode werden das Ein- und Ausgabe Bild, die Schwellwertgrenze, der maximale Farbwert und die Wahl des Algorithmus übergeben. 
\inputCPP[label={lst:globalthreshold}][][Binarisierung anhand des globalen Schwellwertverfahrens.]{code/global-binarize.cpp}

Wir haben uns hier auf den Algorithmus von Otsu\footnote{Mehr Information zu dem Algorithmus auf der zugehörigen \OpenCV Seite:\url{http://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html\#threshold}} geeinigt, da er sehr gute Ergebnisse mit einer geringen Laufzeit liefert.

Bei den lokalen Schwellwertverfahren hingegen wird die Methode \texttt{adaptiveThreshold} verwendett. Listing \ref{lst:localthreshold} veranschaulicht die Methode die für die zwei lokalen Verfahren verwendet wird. Für die jeweiligen Verfahren wird der Parameter \texttt{adaptiveMethod} passend übergeben.
\inputCPP[label={lst:localthreshold}][][Binarisierung anhand eines lokalen Schwellwertverfahrens.]{code/local-binarize.cpp}
\begin{figure}[h]
\center
\includegraphics[scale=0.12]{images/qrcode-adler-wand_1___BINARIZED___.jpg}
\hspace{5px}
\includegraphics[scale=0.12]{images/qrcode-adler-wand_2___BINARIZED___.jpg}
\caption{Das Resultat der Binarisierung mit den jeweiligen Verfahren. Links global und Rechts lokal.}
\end{figure}

\textbf{Ausblick:} Durch das verändern des Parameters \texttt{C} in der \texttt{adaptiveThreshold} Methode kann eine ausgeglichenere Binarisierung erzielt werden. Diese Konstante wird von jedem Pixel abgezogen um einen Ausgleich zu schaffen. Allerdings können aus leicht Informationen verloren gehen!

\chapter{Patternidentifikation}
Der nächste Schritt auf dem Weg zur lokalisierung der \QRCodes ist das identifizieren der \emph{Finder Patterns}. Dafür wird die durch \OpenCV bereitgestellte \texttt{findContours} Methode verwendet. Sie basiert auf dem Algorithmus von Suzuki und wird eingesetzt um die Konturen aus dem Binärbild zu bestimmen.
\inputCPP[label={lst:findcontours}][][Aufruf der \texttt{findContours} Methode um die Konturen zu bestimmen.]{code/findContours.cpp}
Listing \ref{lst:findcontours} zeigt den Aufruf um alle Konturen des übergebenen Bildes zu erhalten.

\section{Vorgehensweise des Algorithmus von Suzuki}
Das Binärbild wird als ein Raster durch iterriert. Für jeden Pixel $p_{i,j}$ wird geprüft ob er die Bedingungen erfüllt ein Teil einer Kontur sein könnte. Das Paper   \todo{verweis}  führt hierzu zwei Formen von Konturen ein \emph{outer border} und \emph{hole border}. Sind beide Bedingungen erfüllt ist der Pixel $p_{i,j}$ ein Anfangspunkt einer neuen Kontur. Diese Kontur muss eindeutig identifizierbar sein daher wird sie mit einer \emph{KonturID} versehen. Großer Vorteil dieses Algorithmus ist die abgespeicherte Hierarchy der Konturen. Um dies zu gewährleisten muss die \emph{parent}-Kontur für die neue Kontur gesetzt werden. Während des scannens des Gitters wird immer die äußere Kontur zwischen gespeichert, diese ist entweder die \emph{parent}-Kontur oder die Kontur die, die neue Kontur und die \emph{parent}-Kontur teilt. Wenn alle Werte gesetzt sind, wird die Kontur durch sukzessives hinzunehmen von Pixeln erzeugt. Nach jeder Kontur erzeugung springt der Algorithmus zurück zum Raster Scan. Der Algorithmus terminiert bei erreichen der rechten unteren Ecke.

Das Orginal Paper beschreibt ausfürlich das Vorgehen anhand Beispielen und Pseudocode.

\section{Filtern der Konturen}
Nachdem die Konturen bestimmt wurden, müssen die Konturen gefiltert werden da abhängig vom Bild können eine variable Anzahl an Konturen
erkannt werden. Beispielsweise werden bei der Ausführung der adaptiven Schwellwertoperation sehr viele zu kleine Konturen erkannt. Daher werden Konturen in folgenden Fällen ignoriert:
\begin{enumerate}
	\item Die Kontur ist zu klein oder zu groß.
	\item Die Kontur besitzt kein \emph{parent}-Kontur.
	\item Konturen die Nachbarkonturen besitzen.
	\item Konturen die eine \emph{child}-Kontur besitzen.
\end{enumerate}
Für die äußeren Konturen also die \emph{parent}-Konturen müssen die Bedingungen 1.-3. natürlich auch gelten. Zusätzlich muss für die äußerste Kontur eine Trapezoide Form gelten.

